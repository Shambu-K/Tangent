%option noyywrap nodefault 

D               [0-9]
L               [a-zA-Z]

%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include "parser.hh"
    #include "location.hh"

    #define YY_USER_ACTION yylloc->step(); yylloc->columns(yyleng); // Called before each token
    void comment();
    
    typedef yy::parser::token token;
%}

%%
"#"                    {comment();}

"const"                 {return CONST;}
"var"                   {return VAR;}

"bool"                  {return BOOL;}
"float"                 {return FLOAT;}
"int"                   {return INT;}
"string"                {return STRING;}
"void"                  {return VOID;}
"Point"                 {return POINT;}
"Path"                  {return PATH;}                  
"Image"                 {return IMAGE;}
"Rectangle"             {return RECTANGLE;}
"Circle"                {return CIRCLE;}
"Ellipse"               {return ELLIPSE;}
"Polygon"               {return POLYGON;}
"Curve"                 {return CURVE;}
"Pi"                    {return PI;}
"Colour"                {return COLOUR;}

{D}+                   {yylval.valuei = atoi(yytext);return INTEGER_LITERAL;}
{D}+"."{D}+            {yylval.valuef = atof(yytext);return FLOAT_LITERAL;}
\"([^\\\"]|\\.)*\"     {*(yytext + yyleng - 1) = '\0'; yytext++; return STRING_LITERAL;}
"true"                 {yylval.valueb = true; return BOOL_LITERAL;}
"false"                {yylval.valueb = false; return BOOL_LITERAL;}

"if"                   {return IF;}
"else"                 {return ELSE;}
"switch"               {return SWITCH;}
"case"                 {return CASE;}
"default"              {return DEFAULT;}
"while"                {return WHILE;}
"for"                  {return FOR;}
"break"                {return BREAK;}
"continue"             {return CONTINUE;}
"send"                 {return SEND;} 

"family"               {return FAMILY;}
"::"                   {return INHERITS;}  
"public"               {return PUBLIC;}
"private"              {return PRIVATE;}

"driver"               {return DRIVER;}

{L}({L}|{D}|_)*        {auto temp = new string(yytext);yylval.id = temp; return IDENTIFIER;}

","                    {return ',';}
":="                   {return token::ASSIGN;}
"+="                   {return token::ADD_ASSIGN;}
"-="                   {return token::SUB_ASSIGN;}
"*="                   {return token::MUL_ASSIGN;}
"/="                   {return token::DIV_ASSIGN;}
"%="                   {return token::MOD_ASSIGN;}
"?"                    {return '?';}
":"                    {return ':';}
"|"                    {return token::LOGICAL_OR;}
"&"                    {return token::LOGICAL_AND;}
"="                    {return token::EQ;}
"!="                   {return token::NOT_EQ;}
"<"                    {return token::LS_THAN;}
"<="                   {return token::LS_THAN_EQ;}
">"                    {return token::GR_THAN;}
">="                   {return token::GR_THAN_EQ;}
"+"                    {return '+';}
"-"                    {return '-';}
"*"                    {return '*';}
"/"                    {return '/';}
"%"                    {return '%';}
"++"                   {return token::INC;}
"--"                   {return token::DEC;}
"!"                    {return token::LOGICAL_NOT;}
("<:"|"(")             {return '(';}
(":>"|")")             {return ')';}
"["                    {return '[';}
"]"                    {return ']';}
">>"                   {return token::SCOPE_ACCESS;}
"(:"                   {return '{';}
":)"                   {return '}';}
";"                    {return ';';}

[ \t\v\f]*             {}
"\n"                   {yylloc->lines(1);}
<<EOF>>                {return token::YYEOF;}

 /* Matches to any invalid tokens not matched to any other rules */
.                      {
                        std::cout << "Invalid token: '" << yytext << "' at location " << *yylloc << std::endl;
                        std::cerr << "Invalid token: '" << yytext << "' at location " << *yylloc << std::endl;
                        return token::YYUNDEF;
                       }
%%

void comment(){
    char c;
    while( (c = yyinput()) != '\n' )
        ; /* eats up any line starting with '#' */
}

#ifdef STANDALONE_LEXER

// The token names generated by bison in parser.tab.c. yytname[i] gives the name of the token with enum value 255 + i;
static const char *const yytname[] =
{
    "end of file", "error", "invalid token", "CONST", "VAR", "BOOL",
    "FLOAT", "INT", "STRING", "VOID", "BOOL_LITERAL", "FLOAT_LITERAL",
    "INTEGER_LITERAL", "STRING_LITERAL", "IF", "ELSE", "SWITCH", "CASE",
    "DEFAULT", "WHILE", "FOR", "BREAK", "CONTINUE", "SEND", "FAMILY",
    "INHERITS", "PUBLIC", "PRIVATE", "DRIVER", "IDENTIFIER", "','", "ASSIGN",
    "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
    "'?'", "':'", "LOGICAL_OR", "LOGICAL_AND", "EQ", "NOT_EQ", "LS_THAN",
    "LS_THAN_EQ", "GR_THAN", "GR_THAN_EQ", "'+'", "'-'", "'*'", "'/'", "'%'",
    "INC", "DEC", "INC_POST", "DEC_POST", "UPLUS", "UMINUS", "LOGICAL_NOT",
    "'('", "')'", "'['", "']'", "SCOPE_ACCESS", "';'", "'{'", "'}'",
};

void print_tokens_matched(const std::string& filename){
    int token;
    yy::parser::semantic_type yylval;
    yy::parser::location_type yylloc;
    yylloc.initialize(&filename);
    while(token = yylex(&yylval, &yylloc)){
        char token_name[20] = "'''";
        if(token < 255) 
            token_name[1] = token;
        else
            strcpy(token_name, yytname[token - 255]);
        std::cout << "Token: " << token_name << " at location " << yylloc << std::endl;
    }
    printf("\n");
}

int main(int argc, char* argv[]){
    if(argc < 2) /* just read stdin */
        print_tokens_matched("(stdin)");
    else{
        for(int i = 1; i < argc; i++){
            FILE *file = fopen(argv[i], "r");
            if(file == NULL){ 
                perror(argv[i]); 
                return 1;
            }
            yyrestart(file);
            print_tokens_matched(argv[i]);
            fclose(file);
        }
    }

    return 0;
}

#endif