%option noyywrap yylineno nodefault 

D               [0-9]
L               [a-zA-Z]


%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    // #include "../src/astNodes.h"
    #include "parser.hh"
    #include "location.hh"

    #define YY_USER_ACTION update_locations(); // Called before each token
    void comment();
    void update_locations();
    
    typedef yy::parser::token token;
%}

%%
"#"                    {comment();}

"const"                {return token::CONST;}
"var"                  {return token::VAR;}

"bool"                 {return token::BOOL;}
"float"                {return token::FLOAT;}
"int"                  {return token::INT;}
"string"               {return token::STRING;}
"void"                 {return token::VOID;}

{D}+                   {yylval->emplace<int>(atoi(yytext)); return token::INTEGER_LITERAL;}
{D}+"."{D}+            {/* yylval.valuef = atof(yytext); */return token::FLOAT_LITERAL;}
\"([^\\\"]|\\.)*\"     {/* *(yytext + yyleng - 1) = '\0'; yytext++; */ return token::STRING_LITERAL;}
"true"                 {/* yylval.valueb = true; */ return token::BOOL_LITERAL;}
"false"                {/* yylval.valueb = false; */ return token::BOOL_LITERAL;}

"if"                   {return token::IF;}
"else"                 {return token::ELSE;}
"switch"               {return token::SWITCH;}
"case"                 {return token::CASE;}
"default"              {return token::DEFAULT;}
"while"                {return token::WHILE;}
"for"                  {return token::FOR;}
"break"                {return token::BREAK;}
"continue"             {return token::CONTINUE;}
"send"                 {return token::SEND;} 

"family"               {return token::FAMILY;}
"::"                   {return token::INHERITS;}  
"public"               {return token::PUBLIC;}
"private"              {return token::PRIVATE;}

"driver"               {return token::DRIVER;}

{L}({L}|{D}|_)*        {/* yylval.id = yytext; */ return token::IDENTIFIER;}

","                    {return ',';}
":="                   {return token::ASSIGN;}
"+="                   {return token::ADD_ASSIGN;}
"-="                   {return token::SUB_ASSIGN;}
"*="                   {return token::MUL_ASSIGN;}
"/="                   {return token::DIV_ASSIGN;}
"%="                   {return token::MOD_ASSIGN;}
"?"                    {return '?';}
":"                    {return ':';}
"|"                    {return token::LOGICAL_OR;}
"&"                    {return token::LOGICAL_AND;}
"="                    {return token::EQ;}
"!="                   {return token::NOT_EQ;}
"<"                    {return token::LS_THAN;}
"<="                   {return token::LS_THAN_EQ;}
">"                    {return token::GR_THAN;}
">="                   {return token::GR_THAN_EQ;}
"+"                    {return '+';}
"-"                    {return '-';}
"*"                    {return '*';}
"/"                    {return '/';}
"%"                    {return '%';}
"++"                   {return token::INC;}
"--"                   {return token::DEC;}
"!"                    {return token::LOGICAL_NOT;}
("<:"|"(")             {return '(';}
(":>"|")")             {return ')';}
"["                    {return '[';}
"]"                    {return ']';}
">>"                   {return token::SCOPE_ACCESS;}
"(:"                   {return '{';}
":)"                   {return '}';}
";"                    {return ';';}

[ \t\v\n\f]*           {}
<<EOF>>                {return token::YYEOF;}

 /* Matches to any invalid tokens not matched to any other rules */
.                      {
                            std::cout << "Invalid token: " << yytext << "at location" << *yylloc << std::endl;
                            std::cerr << "Invalid token: " << yytext << "at location" << *yylloc << std::endl;
                        // printf("Error: %s: Line %d:%d\t%-12s - Invalid token\n", yylloc.filename, yylineno, yylloc.first_column, yytext);
                        // fprintf(stderr, "   Error: %s: Line %d:%d - '%s' - Invalid token\n", yylloc.filename, yylineno, yylloc.first_column, yytext);
                        return token::YYUNDEF;
                       }
%%

void update_locations(){
    /* yylloc.first_line = yylloc.last_line = yylineno;
    yylloc.first_column = yylloc.last_column;

    for(auto& c: std::string(yytext)) {
        if(c == '\n'){
            yylloc.last_line++;
            yylloc.last_column = 0;
        }
        else if(c == '\t')
            yylloc.last_column += 4 - (yylloc.last_column % 4);
        else
            yylloc.last_column++;
    } */
}

void comment(){
    char c;
    while( (c = yyinput()) != '\n' )
        ; /* eats up any line starting with '#' */
}

#ifdef STANDALONE_LEXER

// The token names generated by bison in parser.tab.c. yytname[i] gives the name of the token with enum value 255 + i;
static const char *const yytname[] =
{
    "end of file", "error", "invalid token", "CONST", "VAR", "BOOL",
    "FLOAT", "INT", "STRING", "VOID", "BOOL_LITERAL", "FLOAT_LITERAL",
    "INTEGER_LITERAL", "STRING_LITERAL", "IF", "ELSE", "SWITCH", "CASE",
    "DEFAULT", "WHILE", "FOR", "BREAK", "CONTINUE", "SEND", "FAMILY",
    "INHERITS", "PUBLIC", "PRIVATE", "DRIVER", "IDENTIFIER", "','", "ASSIGN",
    "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
    "'?'", "':'", "LOGICAL_OR", "LOGICAL_AND", "EQ", "NOT_EQ", "LS_THAN",
    "LS_THAN_EQ", "GR_THAN", "GR_THAN_EQ", "'+'", "'-'", "'*'", "'/'", "'%'",
    "INC", "DEC", "INC_POST", "DEC_POST", "UPLUS", "UMINUS", "LOGICAL_NOT",
    "'('", "')'", "'['", "']'", "SCOPE_ACCESS", "';'", "'{'", "'}'",
};

void print_tokens_matched(){
    int token;
    yy::parser::semantic_type yylval;
    yy::parser::location_type yylloc;
    while(token = yylex(&yylval, &yylloc)){
        char token_name[20] = "'''";
        if(token < 255) 
            token_name[1] = token;
        else
            strcpy(token_name, yytname[token - 255]);
        /* printf("%s: Line %d:%d\t%-12s was matched to the token %-20s (= %d) \n", yylloc.filename, yylloc.first_line, yylloc.first_column, yytext, token_name, token); */
    }
    printf("\n");
}

int main(int argc, char* argv[]){
    if(argc < 2){ /* just read stdin */
        /* init_yylloc("(stdin)"); */
        print_tokens_matched();
    }
    else{
        for(int i = 1; i < argc; i++){
            /* init_yylloc(argv[i]); */
            FILE *file = fopen(argv[i], "r");
            if(file == NULL){ 
                perror(argv[i]); 
                return 1;
            }
            yyrestart(file);
            print_tokens_matched();
            fclose(file);
        }
    }

    return 0;
}

#endif